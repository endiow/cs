# 操作系统



## 一、操作系统概述

### 1.1 操作系统的定义与目标

定义：操作系统是控制管理计算机系统的硬软件，分配调度资源的系统软件。

目标：**方便性，有效性（提高系统资源的利用率、提高系统的吞吐量）**，可扩充性，开放性。

### 1.2 操作系统的基本功能

![image-20240710095346913](./images/image-20240710095346913.png)

统一管理计算机资源：处理器资源，IO设备资源，存储器资源，文件资源;
实现了对计算机资源的抽象：IO设备管理软件提供读写接口，文件管理软件提供操作文件接;
提供了用户与计算机之间的接口：GUI（图形用户界面），命令形式，系统调用形式。

### 1.3 操作系统的特征

最基本的特征，互为存在条件：并发，共享；

（1）**并行**：指两个或多个事件可以在**同一个时刻**发生，多核CPU可以实现并行，一个cpu同一时刻只有一个程序在运行；

（2）**并发**：指两个或多个事件可以在**同一个时间间隔**发生，用户看起来是每个程序都在运行，实际上是每个程序都**交替执行**。

![image-20240710094314071](./images/image-20240710094314071.png)

（3）**共享性**：操作系统的中资源可供多个并发的程序共同使用，这种形式称之为**资源共享**。

**互斥共享**：虽然可以提供给 多个进程使用，但一个时间段内只允 许一个进程访问该资源
**同时访问**：某种资源并发的被多个程序访问。
**虚拟和异步特性前提是具有并发性。**

（4）**虚拟性**：表现为把一个物理实体转变为若干个逻辑实体。

**时分复用技术**：资源在时间上进行复用，不同程序并发使用，多道程序分时使用计算机的硬件资源，提高资源的利用率。
**空分复用技术**：用来实现虚拟磁盘（物理磁盘虚拟为逻辑磁盘，电脑上的C盘、D盘等）、虚拟内存（在逻辑上扩大程序的存储容量）等，提高资源的利用率，提高编程效率。

（5）**异步性**：在多道程序环境下，允许多个进程并发执行，但由于资源等因素的限制，使进程的执行以“停停走走”的方式运行，而且每个进程执行的情况（运行、暂停、速度、完成）也是未知的。

### 1.4 操作系统的中断处理

中断机制的作用：为了在多道批处理系统中让用户进行交互；

**中断产生：**

- 发生中断时，CPU立马切换到管态，开展管理工作；（管态又叫特权态，系统态或核心态，是操作系统管理的程序执行时，机器所处的状态。）
- 发生中断后，当前运行的进程会暂停运行，由操作系统内核对中断进行处理；
- 对于不同的中断信号，会进行不同的处理。

**中断的分类：**

![image-20240710095436767](./images/image-20240710095436767.png)

- 内中断（也叫“异常”、“例外”、“陷入”）------- 信号来源：CPU内部，与当前执行指令有关；
- 外中断（中断）----------信号来源：CPU外部，与当前执行指令无关。

**外中断的处理过程：**

1. 每执行完一个指令后，CPU都需要检查当前是否有外部中断 信号；
2. 如果检查到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW，程序计数器PC、各种通用寄存器）把他们存储在PCB（进程控制块中）；
3. 根据中断信号类型转入相应的中断处理程序；
4. 恢复原进程的CPU环境并退出中断，返回原进程继续执行。





## 二、进程管理

### 2.1 进程管理之进程实体

为什么需要进程：

- 进程是系统进行**资源分配和调度的基本单位**；
- 进程作为程序独立运行的载体保障程序正常执行；
- 进程的存在使得操作系统资源的利用率大幅提升。

**进程控制块（PCB）：用于描述和控制进程运行的通用数据结构,记录进程当前状态和控制进程运行的全部信息，是进程存在的唯一标识。**

![image-20240710095536962](./images/image-20240710095536962.png)



### 2.2 进程管理之五状态模型

**进程的状态图:**

**就绪状态**：其它资源（进程控制块、内存、栈空间、堆空间等）都准备好、只差CPU的状态。
**执行状态**：进程获得CPU，其程序正在执行。
**阻塞状态**：进程因某种原因放弃CPU的状态，阻塞进程以队列的形式放置。
**创建状态**：创建进程时拥有PCB但其它资源尚未就绪。
**终止状态**：进程结束由系统清理或者归还PCB的状态。

###### ![image-20240710095727294](./images/image-20240710095727294.png)

备注: PCB是有限的, 申请失败即创建失败, 若有**PCB而资源不足**(如内存)则处于创建态



### 2.3  线程的简介

**进程（Process）与线程（Thread）：**

线程：操作系统进行**运行调度的最小单位**。
进程：系统进行**资源分配和调度的基本单位**。

![image-20240710100311708](./images/image-20240710100311708.png)

**区别与联系：**

- **本质区别**：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。
- **包含关系**：一个进程至少有一个线程，线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。
- **资源开销**：每个进程都有独立的地址空间，进程之间的切换会有较大的开销；线程可以看做轻量级的进程，同一个进程内的线程共享进程的地址空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。
- **影响关系**：一个进程崩溃后，在保护模式下其他进程不会被影响，但是一个线程崩溃可能导致整个进程被操作系统杀掉，所以多进程要比多线程健壮。

![image-20240710100411374](./images/image-20240710100411374.png)

### 	

### 2.4 线程的实现

#### 用户线程

**由一组用户级线程函数来完成线程的管理, 包括线程的创建, 终止, 同步和调度等。**

特点:

- 由线程库函数来维护, 可以用于不支持线程技术的多进程操作系统。
- 不需要从用户态切换到内核态, 速度快。但调度仍然是进程为单位
- 当进程某个线程发出系统调用的请求时, 会把整个进程都阻塞起来, 影响其他线程的正常运行。
- 对线程的调度算法可以自定义



#### 内核线程

**在操作系统的内核实现线程机制, 由操作系统内核来完成线程的创建, 终止, 管理。**

特点:

- PCB和TCB都存在内核空间中, 由内核维护, 一般的用户程序不能访问。
- 线程的创建, 终止和切换都是通过系统调用的方式来进行, 需要从用户态转换到系统态, 开销较大。
- 某个线程引起的系统调用而被阻塞, 不会影响到其他线程的运行。
- 线程是CPU调度的基本单位, 时间片是分配给线程的,  进程内线程越多, 获得的CPU时间就越多。

![image-20240710100838117](./images/image-20240710100838117.png)



### 2.5 进程间的通信

**低级通信:** 进程之间只能传递少量的控制信息, 如: **信号量**。

**高级通信:** 进程之间可以传送任意数量的数据, 如: **共享内存, 消息传递, 管道**。



#### **共享内存**

操作系统提供一些**API函数**, 运行多个进程把自己地址空间的某部分共享出来, 映射到相同的一块物理内存区域。分为基于**数据结构的共享**(低级通信)和**基于存储区的共享**



#### **消息传递**（套接字）

进程之间通过发送和接受消息来交换信息, 由操作系统来维护, 调用**发送和接受操作**来交换消息。

**直接通信方式原理图:**

![image-20240710101046421](./images/image-20240710101046421.png)

**间接通信方式:**

![image-20240710101109812](./images/image-20240710101109812.png)

#### **管道**

- 管道是一种半双工的通信机制，**只允许数据在一个方向上流动**。当需要双向通信时，需要建立两个独立的管道。它主要用于具**有亲缘关系的进程**之间进行通信，例如父子进程或者兄弟进程。
- 管道在操作系统中单独构成一种独立的文件系统，但与普通文件不同，它只存在于内存中，不属于任何文件系统。管道两端的进程将其视为一个文件，通过写入和读取数据来进行通信。
- 数据在管道中的读取和写入是按照**先进先出**的原则进行的。一个进程向管道中写入的内容被另一个进程从管道的另一端读取。写入的内容被添加在管道缓冲区的末尾，并且从缓冲区的头部逐个读取。

![image-20240710101535125](./images/image-20240710101535125.png)





### 2.6 进程的同步

#### 进程的互斥与同步

如果当前有一个进程正在使用共享数据, 那么其他进程暂时不能去访问该共享数据。

- **互斥的原因**: CPU只有一个, 多个进程竞争的访问同一个共享资源。
- **临界区**: 对共享内存或文件的访问, 可能会引起竞争状态的那段程序。
- **临界资源**: 需要互斥访问的共享资源。

![image-20240710101732352](./images/image-20240710101732352.png)

原则:

- **空闲让进**: 临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；
- **忙则等待**: 当已有进程进入临界区时，其他试图进入临界区的进程必须等待；
- **有限等待**: 对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；
- **让权等待**: 当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。



#### 信号量

信号量是一个**计数器**，用于控制多个进程对共享资源的访问，其主要目的是实现进程间的同步。

使用信号量的基本流程如下：

1. 创建一个信号量：调用者需要指定初始值，通常为1或0，用于控制共享资源的访问权限。
2. 等待信号量：该操作会测试信号量的值，如果其值小于等于0，进程将被阻塞，直到信号量的值大于0。这个操作也被称为**P操作**。
3. 发送信号量：该操作将信号量的值加1，以允许其他等待进程继续执行。这个操作也被称为**V操作**。
4. 为了确保信号量操作的原子性，信号量通常在内核中实现。在Linux环境中，有三种主要类型的信号量：Posix信号量（Portable Operating System Interface for Unix），有名信号量（使用Posix IPC命名标识），以及基于内存的Posix信号量（存储在共享内存区中）。此外，还有System V信号量，它也常用于进程间或线程间的同步。



#### 管程

`可以将管程理解为一个房间，这个房间里有一些共享的资源，比如变量、队列等。同时，房间里有一个门，只有一把钥匙。多个线程或进程需要访问房间内的资源时，它们需要先获得这把钥匙，一次只能有一个线程或进程持有钥匙，进入房间并访问资源。其他线程或进程必须等待，直到当前持有钥匙的线程或进程释放钥匙，才能获得钥匙进入房间。`

`此外，管程还提供了条件变量，类似于房间内的提示牌。线程在进入房间后，如果发现某个条件不满足（比如队列为空），它可以通过条件变量来知道自己需要等待，暂时离开房间，并将钥匙交给下一个等待的线程。当其他线程满足了等待的条件（比如向队列中添加了元素），它可以通过条件变量通知告诉正在等待的线程，使其重新获得钥匙进入房间，并继续执行。`

管程由以下几个主要部分组成：

- **共享变量**：管程中包含了共享的变量或数据结构，多个线程或进程需要通过管程来访问和修改这些共享资源。
- **互斥锁（Mutex）**：互斥锁是管程中的一个关键组成部分，用于确保在同一时间只有一个线程或进程可以进入管程。一旦一个线程或进程进入管程，其他线程或进程必须等待，直到当前线程或进程退出管程。
- **条件变量（Condition Variables）**：条件变量用于实现线程或进程之间的等待和通知机制。当一个线程或进程需要等待某个条件满足时（比如某个共享资源的状态），它可以通过条件变量进入等待状态。当其他线程或进程满足了这个条件时，它们可以通过条件变量发送信号来唤醒等待的线程或进程。
- **管程接口（对管程进行操作的函数）**：管程还包括了一组操作共享资源的接口或方法。这些接口定义了对共享资源的操作，并且在内部实现中包含了互斥锁和条件变量的管理逻辑。其他线程或进程通过调用这些接口来访问共享资源，从而确保了对共享资源的有序访问。



#### 生产者 - 消费者问题

有一群生产者进程在生产产品，并将这些产品提供给消费者进程进行消费，生产者进程和消费者进程可以并发执行，在两者之间设置了一个具有n个缓冲区的缓冲池，生产者进程需要将所生产的产品放到缓冲区中（+1操作），消费者进程可以从缓冲区取走产品消费（-1操作）。

![image-20240710110912778](./images/image-20240710110912778.png)



#### 哲学家就餐问题

5 个沉默寡言的哲学家围坐在圆桌前，每人面前一盘意面。叉子放在哲学家之间的桌面上。（5 个哲学家，5 根叉子）

所有的哲学家都只会在思考和进餐两种行为间交替。哲学家只有同时拿到左边和右边的叉子才能吃到面，而同一根叉子在同一时间只能被一个哲学家使用。每个哲学家吃完面后都需要把叉子放回桌面以供其他哲学家吃面。只要条件允许，哲学家可以拿起左边或者右边的叉子，但在没有同时拿到左右叉子时不能进食。

假设面的数量没有限制，哲学家也能随便吃，不需要考虑吃不吃得下。
设计一个进餐规则（并行算法）使得每个哲学家都不会挨饿；也就是说，在没有人知道别人什么时候想吃东西或思考的情况下，每个哲学家都可以在吃饭和思考之间一直交替下去。

**解决思路**

1) **最多同时允许4个哲学家拿筷子**

2) **要求奇数号哲学家先拿左边的筷子, 偶数号哲学家刚好相反**
   
3) **仅当一个哲学家左右两支筷子都可用时才允许他抓起筷子**



### 2.7 进程调度

**CPU繁忙的进程**: 大部分时间处于运行状态和就绪状态。

**I/O繁忙的进程**: 大部分时间处于阻塞状态。

**不可抢占调度方式**: 一个进程若被选中, 就一直运行下去, 直到被阻塞或主动交出CPU。

**可抢占调度方式**: 进程在运行时, 调度程序可以随时打断它。




#### 调度的三个层次

**高级调度**：也称作业调度。由于内存的有限，有时无法将作业全部放入内存，一部分要放到外存。高级调度会从外存的后备队列中选一个或多个作业，调入内存中，创建PCB。(使进程处于创建态)。**高级调度是对作业的调度,选中的作业将会为其创建进程.**

**中级调度**:也称内存调度。还是由于内存不足的原因，当进程过多，内存无法支撑所有进程同时执行，就可以将一部分不重要不紧急的进程挂起（原语操作），放至外存中。等待进程重新具备了运行条件时并且内存有空闲时再重新调入内存。

暂时调入外存的进程处于挂起状。挂起时，进程的程序段和数据段会被放至外存中，而PCB加入挂起队列中（依旧在内存中），记录着进程的各种信息包括进程在外存的位置。(使进程处于挂起态)

**低级调度**：也称进程调度。按照某种策略选取就绪队列中的进程，将处理机的资源分配给它。使进程从就绪态处于运行态。

![image-20240710232624348](images/image-20240710232624348.png)

![image-20240710232822112](images/image-20240710232822112.png)

#### 调度算法

调度算法的评价指标:

- CPU利用率: CPU忙碌时间 / 总时间

- 系统吞吐量: 作业总数 / 总时间

- 周转时间: 作业完成时间 - 作业提价时间 (小作业比大作业小,体现不出, 因此有带权周转时间)

- 平均周转时间: 各周转时间总和/作业数 (排队上厕所例子, 一定时间内上厕所人数越多越好)

  ![image-20240710233439793](images/image-20240710233439793.png)

##### 先来先服务(FCFS First Come First Serve)

**算法思想**：先来后到，每次从就绪队列选择最优先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续在队列中选择下一个第一个进程继续运行，属于非抢占

**作业调度**：考虑的是哪个作业先到达后备队列
**进程队列**：考虑的是哪个进程先到达就绪队列

优缺点
**优点**： 公平、算法实现简单
**缺点**： 如果带权周转时间很大，表明该进程只需很短的时间能被处理，却还要花费很长时间处理。这就像你在屏幕上打字，明明是瞬间的事情，但是却要卡半天才能出来
**适用情况**：**对长作业有利，对短作业不利。适用于CPU繁忙型作业的系统，不适用于I/O繁忙型作业的系统**



##### 短作业优先算法 （SJF, Shortest Job First）

**算法思想**：**最短（要求服务时间最短）的作业/进程优先得到服务，既可以用于作业调度，也可以用于进程调度**

**不可抢占方式**: 即使来了一个更短的作业, 也不会被打断。

**可抢占方式**: 新的短作业到来, 当其运行时间小于正在运行的作业的剩余时间, 则立即抢占CPU。即 **最短剩余时间优先算法**（**SRTN**, Shortest Remaining Time Next）

特点:

- 平均等待时间短,平均周转时间最少
- 对短作业有利, 对长作业不利
- 会导致进程饥饿



##### **高响应比优先（HRRN, Highest Response Ratio Next）**

**在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务 。**

**响应比: 等待时间+要求服务时间 / 要求服务时间** 

特点:

- 综合考虑了等待时间和运行时间, 
- 对于长作业来说，等待时间越来越久，响应比越大，避免了长作业饥饿



**三者比较**

![image-20240710234117678](images/image-20240710234117678.png)



##### RR（轮转）

**这是一个抢占式算法！**

最古老、最简单、最公平且使用最广的算法就是**时间片轮转**（Round Robin, RR）调度算法。

每个进程被分配一个时间段，称为**时间片**（Quantum），即允许该进程在该时间段中运行。

- 如果时间片用完，进程还在运行，那么将会把此进程从 CPU 释放出来，并把 CPU 分配另外一个进程；
- 如果该进程在时间片结束前阻塞或结束，则 CPU 立即进行切换；

另外，时间片的长度就是一个很关键的点：

- 如果时间片设得太短会导致过多的进程上下文切换，降低了 CPU 效率；
- 如果设得太长又可能引起对短作业进程的响应时间变长



##### 优先级算法

每个进程都设置一个**优先级**, 然后在所有就绪的进程中选择优先级最高的运行。类似短作业优先算法, 以运行时间长短定优先级。**优先级相同的采用优先级队列, 进行时间片轮转法。**

- **静态优先级**: 创建进程是确定进程的优先级并一直保持不变。缺点是低优先级可能一直处于饥饿状态。
- **动态优先级**: 有初始优先级, 可根据进程的等待时间的增加而增加优先级, 或用完时间片后降低进程的优先级。

特点:

- 会导致饥饿
- 系统进程优先级 高于 用户进程, 更偏好 I/O型进程（或称 I/O繁忙型进程）



##### 多级反馈队列算法

- 多级：表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短
- 反馈：表示如果有新的进程加入优先级高的队列时，立刻停止当前正在运行的进程，转而去运行优先级高的队列，所以事抢占型算法

**算法具体规则**

- 设置了多个队列，赋予每个队列**不同的优先级**，每个队列优先级从高到低，同时优先级越高时间片越短

- 新的进程会被放入到第一级队列的末尾，按**FCFS**算法的原则排队等待被调度，如果在第一级队列规定的时间片内没有运行完毕，则将其转入第二级队列的末尾，依次类推，直至完成

- 当较高优先级的队列为空时，才调度较低优先级队列中的进程。如果进程运行时，有新的进程进入较高优先级队列时，则停止当前运行的进程并将其移入原队列的末尾，接着让较高优先级的进程运行

对于短作业可能可以在第一级队列很快被处理完。对于长作业，如果在第一级队列处理不完，可以移入下次队列等待被执行，虽然等待的时间变长了，但是运行时间也会更长了，所以该算法很好的**兼顾了长短作业，同时有较好的响应时间。**

![image-20240710234502286](images/image-20240710234502286.png)



### 2.8 死锁

#### 死锁概念

**进程之间对资源的竞争访问所引发的相互等待, 相互妨碍的现象。**

**死锁定义**: 在一组进程中, 每一个进程都占用着若干资源, 同时它又在等待另外一个进程所占用的其他资源, 从而造成所有进程都无法进行下去的现象。 这一组相关的进程称为死锁进程。

- **可抢占的资源:** 进程正在使用资源时, 可以把它拿走而不会对该进行造成任何不良影响。
- **不可抢占的资源**: 进程正在使用这种类型资源时, 强行拿走将导致该进程运行失败, 如光盘刻录机。

死锁发生的4个**必要不充分条件**:

- **互斥条件**: 任何时刻, 每一个资源最多只能被一个进程所使用。
- **请求和保持条件**: 进程在占用若干资源的同时有同时可以去申请新的资源。
- **不可抢占条件**: 进程占用的资源, 不会被强行拿走, 必须由进程主动释放。
- **循环等待条件**: 存在一条由两个或多个进程所组成的环路链, 每一个进程都在等待环路链中下一个进程所占用的资源。**死锁一定有环。**

![image-20240710235633326](images/image-20240710235633326.png)



#### 死锁的检测

**检测死锁的算法**：在资源分配图中，找出既不阻塞又不是孤点的进程。消去它所有的请求边和分配变，使之称为孤立的结点。重复以上步骤。若能消去途中所有的边，则称该图是可完全简化的。

**死锁定理**：**如果某时刻系统的资源分配图是不可完全简化的，那么此时系统死锁**

![image-20240710235602970](images/image-20240710235602970.png)



#### 死锁的解除

- **进程回退**: 类似快照功能, 回退的实现需要系统定期进行备份, 增加系统开销。 
- **剥夺资源**: 把资源从一个进程中剥夺出来, 被剥夺的进程付出的代价取决于资源自身性质。
- **撤销进程**: 杀死进程, 尽可能选择那些能够安全重新运行的进程。



#### 死锁的避免

银行家算法：

1. **检查当前资源剩余是否可以满足某个进程的最大需求；**
2. **如果可以，就把该进程加入安全序列，等待进程允许完成，回收所有资源；**
3. **重复1，2，直到当前没有线程等待资源；**

银行家算法的核心思想在于：在进程提出资源申请时，先预判此次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待。

![image-20240711000059498](images/image-20240711000059498.png)



#### 死锁的预防

**破坏死锁产生的4个必要条件之一。**

- ##### **破坏“不抢占”条件**

  **当某个进程请求新的资源得不到满足时，便立即释放保持的所有资源，待以后需要时再重新申请。**缺点是实现复杂，抢占资源可能导致部分工作失效，反复申请和释放导致系统开销很大，也可能导致饥饿。

- ##### 破坏“请求和保持”条件

  **第一种协议**： 该协议规定，所有进程在开始运行之前，必须一次性地申请其在整个运行过程中所需的全部资源。此时若系统有足够的资源分配给某进程，便可把其需要的所有资源分配给它,这样，该进程在整个运行期间，便不会再提出资源要求，从而破坏了“请求”条件。系统在分配究源时，只要有一种资源不能满足进程的要求，即使其它所需的各资源都空闲也不分配给该进程；

  `*第一种协议虽然简单易行且安全，但是它导致资源被严重浪费，严重的降低了资源的利用率；进程会经常发生饥饿现象。 因此比较推荐第二种协议。*`

  **第二种协议**： 该协议是对第一种协议的改进，它允许一个进程只获得运行初期所需的资源后，便开始运行。进程运行过程中再逐步释放已分配给自己的、且已用毕的全部资源，然后再请求新的所需资源。

- ##### 破坏“循环等待”条件

  **具体做法： 首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源(即编号相同的资源) 一次性申请完；**
  **原理**： 一个进程只有已占有小编号的资源时，才有资格申请更大编号的资源。按此规则，已持有大编号资源的进程不可能逆向地回来申请小编号的资源，从而就不会产生循环等待的现象，进而预防死锁的发生。

  **缺点**

  - 不方便增加新的设备，因为可能需要重新分配所有的编号；
  - 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费;
  - 必须按规定次序申请资源，用户编程麻烦。
